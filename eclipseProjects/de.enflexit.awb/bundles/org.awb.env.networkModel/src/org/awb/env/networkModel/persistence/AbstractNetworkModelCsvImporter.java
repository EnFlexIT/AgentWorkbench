package org.awb.env.networkModel.persistence;

import java.awt.Frame;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Enumeration;
import java.util.TreeMap;
import java.util.Vector;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import javax.swing.JOptionPane;
import org.awb.env.networkModel.NetworkModel;

import agentgui.core.application.Application;
import de.enflexit.common.csv.CSV_FilePreview;
import de.enflexit.common.csv.CsvDataController;

/**
 * Abstract superclass for CSV-based network model importer implementations, providing some basic functionality.
 * @author Christian Derksen - SOFTEC - University of Duisburg-Essen
 * @author Nils Loose - SOFTEC - University of Duisburg-Essen 
 */
public abstract class AbstractNetworkModelCsvImporter extends AbstractNetworkModelFileImporter {

	private final String separator = ";";
	private final boolean hasHeadline = true;

	private String errTitle;
	private String errMessage;

	private TreeMap<String, CsvDataController> csvDataController;
	private static CSV_FilePreview csvFilePreview;

	private NetworkModel networkModel;


	protected boolean debug = false;
	private Vector<String> validFileNames;
	
	/* (non-Javadoc)
	 * @see org.awb.env.networkModel.controller.NetworkModelFileImporter#cleanupImporter()
	 */
	@Override
	public void cleanupImporter() {

		this.errTitle = null;
		this.errMessage = null;
		this.validFileNames = null;
		this.csvDataController = null;

		if (this.isDebug() == false && csvFilePreview != null) {
			csvFilePreview.setVisible(false);
			csvFilePreview.dispose();
			csvFilePreview = null;
		}
		this.networkModel = null;
	}

	
	/**
	 * Sets the valid file names.
	 * @param validFileNames the new valid file names
	 */
	public void setValidFileNames(Vector<String> validFileNames) {
		this.validFileNames = validFileNames;
	}
	/**
	 * Gets the valid file names.
	 * @return the valid file names
	 */
	public Vector<String> getValidFileNames() {
		if (validFileNames==null) {
			validFileNames = this.getListOfRequiredFileNames();
		}
		return validFileNames;
	}
	/**
	 * Gets the list of valid file names for the specific implementation
	 * @return the list of valid file names
	 */
	protected abstract Vector<String> getListOfRequiredFileNames();
	

	/**
	 * Gets the current NetworkModel that has to be generated by this importer.
	 * @return the network model
	 */
	protected NetworkModel getNetworkModel() {
		if (networkModel == null) {
			networkModel = new NetworkModel();
			networkModel.setGeneralGraphSettings4MAS(this.graphController.getNetworkModel().getGeneralGraphSettings4MAS());
		}
		return networkModel;
	}

	/**
	 * Reads the data from the CSV files and stores it in separate {@link CsvDataController}s.
	 * If not all files could be found an error will be shown.
	 * 
	 * @param graphFile the file to read
	 * @return true, if successful
	 * 
	 * @see #getCsvDataController()
	 */
	protected boolean readCsvFiles(File graphFile) {
		return this.readCsvFiles(graphFile, false);
	}
	/**
	 * Reads the data from the CSV files and stores it in separate {@link CsvDataController}s.
	 *
	 * @param graphFile the file to read
	 * @param isAllowIncompleteFileList the indicator if an incomplete list of file is allowed or not
	 * @return true, if successful
	 * 
	 * @see #getCsvDataController()
	 */
	protected boolean readCsvFiles(File graphFile, boolean isAllowIncompleteFileList) {

		boolean successful = true;
		if (this.getFileNameExtension(graphFile).equals(".zip")) {
			// --- Read the zip files ---------------------
			successful = this.readFilesFromZip(graphFile);

		} else if (this.getFileNameExtension(graphFile).equals(".csv")) {
			// --- Read the specified csv files -----------
			File folder = graphFile.getParentFile();
			if (folder != null) {
				successful = this.readFilesFromFolder(folder);
			}
		}

		// ---- Some final error handling here ------------
		if (isAllowIncompleteFileList==false && this.getCsvDataController().size()<this.getValidFileNames().size()) {
			this.errTitle = "Incomplete Import:";
			this.errMessage = "Missing standard csv files within the selection (found " + this.getCsvDataController().size() + " of " + this.getValidFileNames().size() + " required files)!";
			successful = false;
		}
		return successful;
	}
	
	private String getFileNameExtension(File file) {
		int lastPointIndex = file.getName().lastIndexOf(".");
		if (lastPointIndex>0) {
			return file.getName().substring(lastPointIndex, file.getName().length());
		} else {
			return null;
		}
	}

	/**
	 * Read files from the specified folder.
	 *
	 * @param folder the folder, where files should be located
	 * @return true, if successful
	 */
	private boolean readFilesFromFolder(File folder) {
		for (File fileEntry : folder.listFiles()) {
			if (fileEntry.isDirectory() == false && this.getValidFileNames().contains(fileEntry.getName())) {
				// --- Create CsvDataController for the file --------
				CsvDataController csvDC = new CsvDataController(fileEntry, this.separator, this.hasHeadline);
				csvDC.doImport();
				// --- Remind the controller for next steps ---------
				this.getCsvDataController().put(fileEntry.getName(), csvDC);
			}
		}
		return true;
	}

	/**
	 * Read files from the specified zip file.
	 *
	 * @param graphFile the graph file
	 * @return true, if successful
	 */
	private boolean readFilesFromZip(File graphFile) {

		ZipFile zipFile = null;
		try {
			// --- Read the zip file content ------------------------
			zipFile = new ZipFile(graphFile);
			Enumeration<? extends ZipEntry> entries = zipFile.entries();
			while (entries.hasMoreElements()) {
				ZipEntry entry = entries.nextElement();
				String fileName = entry.getName();
				if (this.getValidFileNames().contains(fileName) == true) {
					// --- valid file name => import ----------------
					InputStream inputStream = zipFile.getInputStream(entry);
					BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));

					// --- Create CsvDataController for the file ----
					CsvDataController csvDC = new CsvDataController();
					csvDC.setHeadline(this.hasHeadline);
					csvDC.setSeparator(this.separator);
					csvDC.doImport(br);
					// --- Remind the controller for next steps -----
					this.getCsvDataController().put(fileName, csvDC);

					inputStream.close();
					br.close();
				}
			}
			zipFile.close();
			return true;

		} catch (IOException ioe) {
			ioe.printStackTrace();

		} finally {
			try {
				zipFile.close();
			} catch (IOException ioe) {
				ioe.printStackTrace();
			}
		}
		return false;
	}

	/**
	 * Shows the current error.
	 */
	protected void showError() {
		if ((this.errTitle!=null && this.errTitle.isEmpty()==false) || this.errMessage!=null && this.errMessage.isEmpty()==false) {
			JOptionPane.showMessageDialog(this.graphController.getGraphEnvironmentControllerGUI(), this.errMessage, this.errTitle, JOptionPane.ERROR_MESSAGE);
		}
	}

	/**
	 * Shows the import preview, if the local variable debug is set to true.
	 */
	protected void showImportPreview() {
		if (this.isDebug() == true) {
			// --- Close preview if still open --
			if (csvFilePreview != null) {
				csvFilePreview.setVisible(false);
				csvFilePreview.dispose();
				csvFilePreview = null;
			}
			// --- Get the owner frame ----------
			Frame owner = Application.getMainWindow();
			// --- Open the import preview ------
			csvFilePreview = new CSV_FilePreview(owner, this.getCsvDataController());
		}
	}
	
	/**
	 * Return the current CSV_FilePreview (if open)  .
	 * @return the CSV file preview dialog
	 */
	public CSV_FilePreview getCSVFilePreviewDialog() {
		return csvFilePreview;
	}

	/**
	 * Gets the CSV data controller for the specified files.
	 * @return the csv data controller
	 */
	public TreeMap<String, CsvDataController> getCsvDataController() {
		if (csvDataController == null) {
			csvDataController = new TreeMap<String, CsvDataController>();
		}
		return csvDataController;
	}
	
	/**
	 * Sets the local debug flag.
	 * @param debug the new debug
	 */
	public void setDebug(boolean debug) {
		this.debug = debug;
	}
	/**
	 * Checks if debugging is enabled.
	 * @return true, if debugging is enabled
	 */
	public boolean isDebug() {
		return this.debug;
	}
	
}
